[
    {
        "document_name": "swarmauri/community/__init__.py",
        "content": "```swarmauri/community/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/community/tools/__init__.py",
        "content": "```swarmauri/community/tools/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/community/tools/base/__init__.py",
        "content": "```swarmauri/community/tools/base/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/community/tools/concrete/__init__.py",
        "content": "```swarmauri/community/tools/concrete/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/community/tools/concrete/EntityRecognitionTool.py",
        "content": "```swarmauri/community/tools/concrete/EntityRecognitionTool.py\nimport json\nfrom transformers import pipeline, logging as hf_logging\nfrom ....standard.tools.base.ToolBase import ToolBase\nfrom ....standard.tools.concrete.Parameter import Parameter\n\nhf_logging.set_verbosity_error()\n\nclass EntityRecognitionTool(ToolBase):\n    def __init__(self):\n        parameters = [\n            Parameter(\"text\",\"string\",\"The text for entity recognition\",True)\n        ]\n        super().__init__(name=\"EntityRecognitionTool\", \n                         description=\"Extracts named entities from text\", \n                         parameters=parameters)\n        \n\n    def __call__(self, text: str) -> dict:\n        try:\n            self.nlp = pipeline(\"ner\")\n            entities = self.nlp(text)\n            organized_entities = {}\n            for entity in entities:\n                if entity['entity'] not in organized_entities:\n                    organized_entities[entity['entity']] = []\n                organized_entities[entity['entity']].append(entity['word'])\n            return json.dumps(organized_entities)\n        except Exception as e:\n            raise e\n        finally:\n            del self.nlp\n```"
    },
    {
        "document_name": "swarmauri/community/tools/concrete/GmailSendTool.py",
        "content": "```swarmauri/community/tools/concrete/GmailSendTool.py\nimport base64\nimport json\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\nfrom googleapiclient import discovery\nfrom google.oauth2 import service_account\nfrom googleapiclient.discovery import build\nfrom swarmauri.standard.tools.base.ToolBase import ToolBase\nfrom swarmauri.standard.tools.concrete.Parameter import Parameter\n\nclass GmailSendTool(ToolBase):\n    SCOPES = ['https://www.googleapis.com/auth/gmail.send']\n\n    def __init__(self, credentials_path: str, sender_email: str):\n        \"\"\"\n        Initializes the GmailSendTool with a path to the credentials JSON file and the sender email.\n\n        Parameters:\n        credentials_path (str): The path to the Gmail service JSON file.\n        sender_email (str): The email address being used to send emails.\n        \"\"\"\n        \n        parameters = [\n            Parameter(\n                name=\"recipients\",\n                type=\"string\",\n                description=\"The email addresses of the recipients, separated by commas\",\n                required=True\n            ),\n            Parameter(\n                name=\"subject\",\n                type=\"string\",\n                description=\"The subject of the email\",\n                required=True\n            ),\n            Parameter(\n                name=\"htmlMsg\",\n                type=\"string\",\n                description=\"The HTML message to be sent as the email body\",\n                required=True\n            )\n        ]\n        \n        super().__init__(name=\"GmailSendTool\", \n                         description=\"Sends an email using the Gmail API.\",\n                         parameters=parameters)\n        self.credentials_path = credentials_path\n        self.sender_email = sender_email\n        \n\n    def authenticate(self):\n        \"\"\"\n        Authenticates the user and creates a Gmail API service for sending emails.\n        \"\"\"\n        credentials = service_account.Credentials.from_service_account_file(\n                self.credentials_path, scopes=self.SCOPES)\n        \n        delegated_credentials = credentials.with_subject(self.sender_email)\n        self.service = build('gmail', 'v1', credentials=delegated_credentials)\n\n    def create_message(self, to: str, subject: str, message_text: str):\n        \"\"\"\n        Create a MIMEText message for sending an email.\n\n        Parameters:\n        sender (str): The email address of the sender.\n        to (str): The email address of the recipient.\n        subject (str): The subject of the email.\n        message_text (str): The HTML body of the email.\n\n        Returns:\n        The created MIMEText message.\n        \"\"\"\n        message = MIMEMultipart('alternative')\n        message['from'] = self.sender_email\n        message['to'] = to\n        message['subject'] = subject\n        mime_text = MIMEText(message_text, 'html')\n        message.attach(mime_text)\n        raw_message = base64.urlsafe_b64encode(message.as_string().encode('utf-8'))\n        return {'raw': raw_message.decode('utf-8')}\n\n    def __call__(self, recipients, subject, htmlMsg):\n        \"\"\"\n        Sends an email to the specified recipients with the given subject and HTML message.\n        \n        Parameters:\n        sender (str): The email address of the sender.\n        recipients (str): The email address of the recipients, separated by commas.\n        subject (str): The subject of the email.\n        htmlMsg (str): The HTML content of the email body.\n\n        Returns:\n        The result of sending the email or an error message if the operation fails.\n        \"\"\"\n        self.authenticate()\n        try:\n            message = self.create_message(recipients, subject, htmlMsg)\n            sent_message = (self.service.users().messages().send(userId='me', body=message).execute())\n            return f\"Email sent successfully to {recipients}\"\n\n        except Exception as e:\n            return f\"An error occurred in sending the email: {e}\"\n        finally:\n            del self.service\n```"
    },
    {
        "document_name": "swarmauri/community/tools/concrete/GmailReadTool.py",
        "content": "```swarmauri/community/tools/concrete/GmailReadTool.py\nimport os\nimport base64\nimport json\nfrom googleapiclient import discovery\nfrom google.oauth2 import service_account\nfrom googleapiclient.discovery import build\nfrom ....standard.tools.base.ToolBase import ToolBase\nfrom ....standard.tools.concrete.Parameter import Parameter\n\nclass GmailReadTool(ToolBase):\n    SCOPES = ['https://www.googleapis.com/auth/gmail.readonly']\n\n    def __init__(self, credentials_path: str, sender_email: str):\n        \"\"\"\n        Initializes the GmailReadTool with a path to the credentials JSON file.\n\n        Parameters:\n        credentials_path (str): The path to the Gmail service JSON file.\n        \"\"\"\n        \n        parameters = [\n            Parameter(\n                name=\"query\",\n                type=\"string\",\n                description='''The query to filter emails. For example, \"is:unread\" or \"from:example@gmail.com\" or \"from:sender@company.com\"''',\n                required=True\n            ),\n            Parameter(\n                name=\"max_results\",\n                type=\"integer\",\n                description='''The number of emails to return. Defaults to 10.'''\n            )\n        ]\n        \n        \n        super().__init__(name=\"GmailReadTool\", \n                         description=\"Read emails from a Gmail account.\", \n                         parameters = parameters)\n        self.credentials_path = credentials_path\n        self.sender_email = sender_email\n        \n\n    def authenticate(self):\n        \"\"\"\n        Authenticates the user and creates a Gmail API service.\n        \"\"\"\n        credentials = service_account.Credentials.from_service_account_file(\n                self.credentials_path, scopes=self.SCOPES)\n        \n        delegated_credentials = credentials.with_subject(self.sender_email)\n        self.service = discovery.build('gmail', 'v1', credentials=delegated_credentials)\n\n\n\n    def __call__(self, query='', max_results=10):\n        \"\"\"\n        Fetches emails from the authenticated Gmail account based on the given query.\n\n        Parameters:\n        query (str): The query to filter emails. For example, \"is:unread\".\n        max_results (int): The maximum number of email messages to fetch.\n\n        Returns:\n        list: A list of email messages.\n        \"\"\"\n        self.authenticate()\n        try:\n            # Call the Gmail API\n            \n            gmail_messages = self.service.users().messages()\n            results = gmail_messages.list(userId='me', q=query, maxResults=max_results).execute()\n            messages = results.get('messages', [])\n            message_data = \"\"\n            for message in messages:\n                \n                msg = gmail_messages.get(userId='me', id=message['threadId'], format=\"full\").execute()\n                headers = msg['payload']['headers']\n                \n                sender = next(header['value'] for header in headers if header['name'] == 'From')\n                subject = next(header['value'] for header in headers if header['name'] == 'Subject')\n                reply_to = next((header['value'] for header in headers if header['name'] == 'Reply-To'), subject)\n                date_time = next(header['value'] for header in headers if header['name'] == 'Date')\n                \n                #part = msg['payload']['parts'][0]\n                #data = part['body']['data']\n                #decoded_data = base64.urlsafe_b64decode(data.encode('ASCII'))\n\n                formatted_msg = f\"\\nsender:{sender} reply-to:{reply_to} subject: {subject} date_time:{date_time}\"\n                \n                message_data += formatted_msg\n                \n            \n            return message_data\n        \n        \n        \n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n            return []\n        \n        finally:\n            del self.service\n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n        \n```"
    },
    {
        "document_name": "swarmauri/community/tools/concrete/SentimentAnalysisTool.py",
        "content": "```swarmauri/community/tools/concrete/SentimentAnalysisTool.py\nfrom transformers import pipeline\nfrom transformers import logging as hf_logging\n\nfrom ....standard.tools.base.ToolBase import ToolBase\nfrom ....standard.tools.concrete.Parameter import Parameter\n\nhf_logging.set_verbosity_error()\n\nclass SentimentAnalysisTool(ToolBase):\n    def __init__(self):\n        super().__init__(\"SentimentAnalysisTool\", \n                         \"Analyzes the sentiment of the given text.\", \n                         parameters=[\n                             Parameter(\"text\", \"string\", \"The text for sentiment analysis\", True)\n                         ])\n        \n\n    def __call__(self, text: str) -> str:\n        try:\n            self.analyzer = pipeline(\"sentiment-analysis\")\n            result = self.analyzer(text)\n            return result[0]['label']\n        except:\n            raise\n        finally:\n            del self.analyzer\n```"
    },
    {
        "document_name": "swarmauri/community/tools/concrete/WebScrapingTool.py",
        "content": "```swarmauri/community/tools/concrete/WebScrapingTool.py\nimport requests\nfrom bs4 import BeautifulSoup\nfrom ....standard.tools.base.ToolBase import ToolBase\nfrom ....standard.tools.concrete.Parameter import Parameter\n\nclass WebScrapingTool(ToolBase):\n    def __init__(self):\n        parameters = [\n            Parameter(\n                name=\"url\",\n                type=\"string\",\n                description=\"URL of the link, website, webpage, etc... to scrape\",\n                required=True\n            ),\n            Parameter(\n                name=\"selector\",\n                type=\"string\",\n                description=\"CSS selector to target specific elements\",\n                required=True\n            )\n        ]\n        \n        super().__init__(name=\"WebScrapingTool\", \n                         description=\"This is a web scraping tool that you can utilize to scrape links, websites, webpages, etc... This tool uses python's requests and BeautifulSoup libraries to parse a URL using a CSS to target specific elements.\", \n                         parameters=parameters)\n\n    def __call__(self, url: str, selector: str) -> str:\n        \"\"\"\n        Fetches content from the specified URL and extracts elements based on the provided CSS selector.\n        \n        Args:\n            url (str): The URL of the webpage to scrape.\n            selector (str): CSS selector to target specific elements in the webpage.\n\n        Returns:\n            str: Extracted text from the selector or an error message.\n        \"\"\"\n        try:\n            response = requests.get(url)\n            response.raise_for_status()  # Raises HTTPError for bad requests (4xx or 5xx)\n\n            html_content = response.content\n            soup = BeautifulSoup(html_content, 'html.parser')\n\n            elements = soup.select(selector)\n            extracted_text = '\\n'.join([element.text for element in elements])\n            return extracted_text\n        except requests.RequestException as e:\n            return f\"Request Exception: {str(e)}\"\n        except Exception as e:\n            return f\"Unexpected error: {str(e)}\"\n```"
    },
    {
        "document_name": "swarmauri/community/tools/concrete/DownloadPdfTool.py",
        "content": "```swarmauri/community/tools/concrete/DownloadPdfTool.py\nimport requests\nfrom typing import Dict\nfrom pathlib import Path\nfrom ...standard.tools.base.ToolBase import ToolBase\nfrom ...standard.tools.concrete.Parameter import Parameter\n\nclass DownloadPDFTool(ToolBase):\n    def __init__(self):\n        parameters = [\n            Parameter(\n                name=\"url\",\n                type=\"string\",\n                description=\"The URL of the PDF file to download\",\n                required=True\n            ),\n            Parameter(\n                name=\"destination\",\n                type=\"string\",\n                description=\"The path where the PDF file will be saved\",\n                required=True\n            )\n        ]\n        \n        super().__init__(name=\"DownloadPDFTool\",\n                         description=\"Downloads a PDF from a specified URL and saves it to a specified path.\",\n                         parameters=parameters)\n\n    def __call__(self, url: str, destination: str) -> Dict[str, str]:\n        \"\"\"\n        Download the PDF from the specified URL and saves it to the given destination path.\n\n        Parameters:\n        - url (str): The URL from where to download the PDF.\n        - destination (str): The local file path where the PDF should be saved.\n        \n        Returns:\n        - Dict[str, str]: A dictionary containing the result message and the destination path.\n        \"\"\"\n        try:\n            # Send a GET request to the specified URL\n            response = requests.get(url, stream=True)\n\n            # Raise an HTTPError if the status code is not 200 (OK)\n            response.raise_for_status()\n\n            # Ensure destination directory exists\n            Path(destination).parent.mkdir(parents=True, exist_ok=True)\n\n            # Open a file at the specified destination path and write the content of the response to it\n            with open(Path(destination), 'wb') as file:\n                for chunk in response.iter_content(chunk_size=8192):\n                    file.write(chunk)\n            \n            return {\n                \"message\": \"PDF downloaded successfully.\",\n                \"destination\": destination\n            }\n\n        except requests.exceptions.RequestException as e:\n            # Handle requests-related errors\n            return {\"error\": f\"Failed to download PDF: {e}\"}\n        except IOError as e:\n            # Handle file I/O errors\n            return {\"error\": f\"Failed to save PDF: {e}\"}\n```"
    },
    {
        "document_name": "swarmauri/community/tools/concrete/PaCMAP.py",
        "content": "```swarmauri/community/tools/concrete/PaCMAP.py\nfrom ....core.tools.ITool import ITool\nfrom ....standard.tools.concrete.Parameter import Parameter  # Update import path as necessary\nimport numpy as np\nimport pacmap  # Ensure pacmap is installed\n\nclass PaCMAPTool(ITool):\n    \"\"\"\n    A tool for applying the PaCMAP method for dimensionality reduction.\n    \"\"\"\n\n    def __init__(self):\n        parameters = [\n            Parameter(\n                name=\"X\",\n                type=\"object\",\n                description=\"X (np.ndarray): The high-dimensional data points to reduce.\",\n                required=True\n            ),\n            Parameter(\n                name=\"n_neighbors\",\n                type=\"integer\",\n                description=\"The size of local neighborhood (in terms of number of neighboring data points) used for manifold approximation.\",\n                required=False\n            ),\n            Parameter(\n                name=\"n_components\",\n                type=\"integer\",\n                description=\"The dimension of the space into which to embed the data.\",\n                required=True\n            ),\n            Parameter(\n                name=\"n_iterations\",\n                type=\"integer\",\n                description=\"The number of iterations used for optimization.\",\n                required=False\n            )\n        ]\n        \n        super().__init__(name=\"PaCMAPTool\", \n                         description=\"Applies PaCMAP for dimensionality reduction.\", \n                         parameters=parameters)\n\n    def __call__(self, **kwargs) -> np.ndarray:\n        \"\"\"\n        Applies the PaCMAP algorithm on the provided dataset.\n\n        Parameters:\n        - kwargs: Additional keyword arguments for the PaCMAP algorithm.\n\n        Returns:\n        - np.ndarray: The reduced dimension data points.\n        \"\"\"\n        # Set default values for any unspecified parameters\n        X = kwargs.get('X')\n        n_neighbors = kwargs.get('n_neighbors', 30)\n        n_components = kwargs.get('n_components', 2)\n        n_iterations = kwargs.get('n_iterations', 500)\n        \n        # Instantiate the PaCMAP instance with specified parameters\n        embedder = pacmap.PaCMAP(n_neighbors=n_neighbors, n_components=n_components, \n                                 n_iters=n_iterations, **kwargs)\n                                 \n        # Fit the model and transform the data\n        X_reduced = embedder.fit_transform(X)\n\n        return X_reduced\n```"
    },
    {
        "document_name": "swarmauri/community/retrievers/__init__.py",
        "content": "```swarmauri/community/retrievers/__init__.py\n# -*- coding: utf-8 -*-\n\n\n```"
    },
    {
        "document_name": "swarmauri/community/retrievers/base/__init__.py",
        "content": "```swarmauri/community/retrievers/base/__init__.py\n# -*- coding: utf-8 -*-\n\n\n```"
    },
    {
        "document_name": "swarmauri/community/retrievers/concrete/__init__.py",
        "content": "```swarmauri/community/retrievers/concrete/__init__.py\n# -*- coding: utf-8 -*-\n\n\n```"
    },
    {
        "document_name": "swarmauri/community/retrievers/concrete/RedisDocumentRetriever.py",
        "content": "```swarmauri/community/retrievers/concrete/RedisDocumentRetriever.py\nfrom typing import List\nfrom redisearch import Client, Query\nfrom ....core.documents.IDocument import IDocument\nfrom ....standard.document_stores.concrete.ConcreteDocument import ConcreteDocument\nfrom ....standard.retrievers.base.DocumentRetrieverBase import DocumentRetrieverBase\n\nclass RedisDocumentRetriever(DocumentRetrieverBase):\n    \"\"\"\n    A document retriever that fetches documents from a Redis store.\n    \"\"\"\n    \n    def __init__(self, redis_idx_name, redis_host, redis_port):\n        \"\"\"\n        Initializes a new instance of RedisDocumentRetriever.\n\n        Args:\n            redis_client (Redis): An instance of the Redis client.\n        \"\"\"\n        self._redis_client = None\n        self._redis_idx_name = redis_idx_name\n        self._redis_host = redis_host\n        self._redis_port = redis_port\n\n    @property\n    def redis_client(self):\n        \"\"\"Lazily initialize and return the Redis client using a factory method.\"\"\"\n        if self._redis_client is None:\n            self._redis_client = Client(self.redis_idx_name, host=self.redis_host, port=self.redis_port)\n        return self._redis_client\n    \n    def retrieve(self, query: str, top_k: int = 5) -> List[IDocument]:\n        \"\"\"\n        Retrieve the most relevant documents based on the given query.\n        \n        Args:\n            query (str): The query string used for document retrieval.\n            top_k (int, optional): The number of top relevant documents to retrieve. Defaults to 5.\n        \n        Returns:\n            List[IDocument]: A list of the top_k most relevant documents.\n        \"\"\"\n        query_result = self.redis_client.search(Query(query).paging(0, top_k))\n        \n        documents = [\n            ConcreteDocument(\n                doc_id=doc.id,\n                content=doc.text,  # Note: Adjust 'text' based on actual Redis document schema\n                metadata=doc.__dict__  # Including full document fields and values in metadata\n            )\n            for doc in query_result.docs\n        ]\n\n        return documents\n\n```"
    },
    {
        "document_name": "swarmauri/community/document_stores/__init__.py",
        "content": "```swarmauri/community/document_stores/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/community/document_stores/base/__init__.py",
        "content": "```swarmauri/community/document_stores/base/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/community/document_stores/concrete/__init__.py",
        "content": "```swarmauri/community/document_stores/concrete/__init__.py\n\n```"
    },
    {
        "document_name": "swarmauri/community/document_stores/concrete/RedisDocumentStore.py",
        "content": "```swarmauri/community/document_stores/concrete/RedisDocumentStore.py\nfrom typing import List, Optional\nfrom ....standard.document_stores.base.DocumentStoreBase import DocumentStoreBase\nfrom ....core.documents.IDocument import IDocument\nimport redis\nimport json\nfrom redis.commands.search.field import TextField, NumericField, TagField\nfrom redis.commands.search.indexDefinition import IndexDefinition, IndexType\n\n\nclass RedisDocumentStore(DocumentStoreBase):\n    def __init__(self, host, password, port, db):\n        \"\"\"Store connection details without initializing the Redis client.\"\"\"\n        self._host = host\n        self._password = password\n        self._port = port\n        self._db = db\n        self._redis_client = None  # Delayed initialization\n\n    @property\n    def redis_client(self):\n        \"\"\"Lazily initialize and return the Redis client using a factory method.\"\"\"\n        if self._redis_client is None:\n            print('here')\n            self._redis_client = redis.Redis(host=self._host, \n                                             password=self._password, \n                                             port=self._port, \n                                             db=self._db)\n            print('there')\n        return self._redis_client\n\n    def add_document(self, document: IDocument) -> None:\n        \n        data = document.as_dict()\n        doc_id = data['id'] \n        del data['id']\n        self.redis_client.json().set(doc_id, '$', json.dumps(data))\n\n    def add_documents(self, documents: List[IDocument]) -> None:\n        with self.redis_client.pipeline() as pipe:\n            for document in documents:\n                pipe.set(document.doc_id, document)\n            pipe.execute()\n\n    def get_document(self, doc_id: str) -> Optional[IDocument]:\n        result = self.redis_client.json().get(doc_id)\n        if result:\n            return json.loads(result)\n        return None\n\n    def get_all_documents(self) -> List[IDocument]:\n        keys = self.redis_client.keys('*')\n        documents = []\n        for key in keys:\n            document_data = self.redis_client.get(key)\n            if document_data:\n                documents.append(json.loads(document_data))\n        return documents\n\n    def update_document(self, doc_id: str, updated_document: IDocument) -> None:\n        self.add_document(updated_document)\n\n    def delete_document(self, doc_id: str) -> None:\n        self.redis_client.delete(doc_id)\n    \n    def __getstate__(self):\n        \"\"\"Return the object state for serialization, excluding the Redis client.\"\"\"\n        state = self.__dict__.copy()\n        state['_redis_client'] = None  # Exclude Redis client from serialization\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Restore the object state after serialization, reinitializing the Redis client.\"\"\"\n        self.__dict__.update(state)\n```"
    }
]